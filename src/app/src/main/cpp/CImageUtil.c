/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//加入libyuv库需要的头文件

#include "libyuv.h"
#include "YLYuvHelper.h"


//实现打印
#include <android/log.h>
#define LOG_TAG "System.out"
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)


/* Header for class com_cmbc_av_jni_ImageFormatUtils */

#ifndef _Included_com_cmbc_av_jni_ImageFormatUtils


#define _Included_com_cmbc_av_jni_ImageFormatUtils
#ifdef __cplusplus
extern "C" {

#endif

/**
 *1. RGBA转NV21,调用yuvHelper;先将RGBA转 ABGR 再转NV21
 * @param env
 * @param clz
 * @param src_argb
 * @param src_stride
 * @param width
 * @param height
 * @param yuvbuffer
 */
JNIEXPORT void JNICALL Java_com_cmbc_av_jni_ImageFormatUtils_RGBAToNV21
        (JNIEnv *env, jclass clz, jbyteArray src_argb, jint src_stride,
                jint width, jint height, jbyteArray yuvbuffer)
{
    uint8_t* srcFrame = (uint8_t*) (*env)->GetByteArrayElements(env, src_argb, 0);
    uint8_t* dst_yuv = (uint8_t*) (*env)->GetByteArrayElements(env, yuvbuffer, 0);
    int vSize = width * height;

    convertRGBAToNV21(srcFrame, src_stride, dst_yuv, width, dst_yuv + vSize, width, width, height);

    (*env)->ReleaseByteArrayElements(env, src_argb, (jbyte*)srcFrame, 0);//这个参数传不传都行,因为客户端没用到
    (*env)->ReleaseByteArrayElements(env, yuvbuffer, (jbyte*)dst_yuv, 0);
}


/**
 * 2.rgba转 NV21,调用yuvHelper 需要转I420,然后裁剪I420,最后将裁剪后的I420转NV21
 * @param env
 * @param clazz
 * @param rgba_data
 * @param rgbaWidth
 * @param rgbaHeight
 * @param nv21_data
 * @param nv21Width
 * @param nv21Height
 * @return
 */
JNIEXPORT jint JNICALL Java_com_cmbc_av_jni_ImageFormatUtils_rgbaToNV21
        (JNIEnv * env, jclass clazz, jbyteArray rgba_data, jint rgbaWidth, jint rgbaHeight
                ,jbyteArray nv21_data, jint nv21Width, jint nv21Height)
{
    uint8_t* srcData = (uint8_t*)(*env)->GetByteArrayElements(env, rgba_data, JNI_FALSE); //原始rbga数据
    uint8_t* dstData = (uint8_t*)(*env)->GetByteArrayElements(env, nv21_data, JNI_FALSE); //nv21数据
    int srcSize = rgbaWidth * rgbaHeight * 3/ 2;
    int croppedSize = nv21Width * nv21Height * 3/ 2;
    unsigned char *srcI420 = malloc(srcSize);
    unsigned char *croppedI420 = malloc(croppedSize);

    if(srcI420 == NULL)
    {
        printf("malloc error");
        return -1;
    }
    if(croppedI420 == NULL)
    {
        printf("malloc error");
        return -1;
    }
    rgbaToNV21(srcData, rgbaWidth, rgbaHeight,srcI420, croppedI420, dstData,nv21Width,nv21Height);

    (*env)->ReleaseByteArrayElements(env, rgba_data, (jbyte*)srcData,JNI_OK);
    (*env)->ReleaseByteArrayElements(env, nv21_data, (jbyte*)dstData,JNI_OK);

    //memory release
    if(srcI420 != NULL)
    {
        free(srcI420);
        srcI420 = NULL;
    }
    if(croppedI420 != NULL)
    {
        free(croppedI420);
        croppedI420 = NULL;
    }
    return 0;
}

/**
 * 3.该方法用于裁剪图片,为了防止图片变形,先按比例缩放,再对图片进行黑边填充,调用yuvHelper
 * @param env
 * @param clazz
 * @param src_data   原始I420数据
 * @param src_width  原始宽度
 * @param src_height 原始高度
 * @param dst_data   目标I420数据
 * @param dst_width  目标宽度
 * @param dst_height 目标高度
 * @return
 */
JNIEXPORT jint JNICALL
Java_com_cmbc_av_jni_ImageFormatUtils_scaleI420(JNIEnv *env, jclass clazz, jbyteArray src_data,
                                                jint src_width, jint src_height,
                                                jbyteArray dst_data, jint dst_width,
                                                jint dst_height,jint rgb_color) {
    uint8_t* srcData = (uint8_t*) (*env)->GetByteArrayElements(env, src_data, 0);
    uint8_t* dstData = (uint8_t*) (*env)->GetByteArrayElements(env, dst_data, 0);

    int ret = scaleAndFillColor(srcData, src_width, src_height, dstData, dst_width, dst_height,rgb_color);

    (*env)->ReleaseByteArrayElements(env, dst_data, (jbyte*)dstData, JNI_OK);
    (*env)->ReleaseByteArrayElements(env, src_data, (jbyte*)srcData, JNI_OK);

    return ret;
}

/**
 * 4. RGBA转I420,直接调用libyuv
 * @param env
 * @param clazz
 * @param rgba_data
 * @param src_stride
 * @param src_width
 * @param src_height
 * @param dst_data
 * @param dst_width
 * @param dst_height
 * @return
 */
JNIEXPORT jint JNICALL
Java_com_cmbc_av_jni_ImageFormatUtils_rgbaToI420(JNIEnv *env, jclass clazz, jbyteArray rgba_data,
                                                 jint src_stride, jint src_width, jint src_height,
                                                 jbyteArray dst_data, jint dst_width,
                                                 jint dst_height) {
    uint8_t* srcData = (uint8_t*) (*env)->GetByteArrayElements(env, rgba_data, 0);
    uint8_t* dstData = (uint8_t*) (*env)->GetByteArrayElements(env, dst_data, 0);

    int ret = convertRGBAToI420(srcData, src_stride, dstData,dst_width,dst_height);
    //
    (*env)->ReleaseByteArrayElements(env, rgba_data, (jbyte*)srcData, JNI_OK);
    (*env)->ReleaseByteArrayElements(env, dst_data, (jbyte*)dstData, JNI_OK);
    return ret;
}

/**
 *5. I420转NV21,直接调用libyuv
 * @param env
 * @param clazz
 * @param i420_data
 * @param width
 * @param height
 * @param nv21_data
 * @return
 */
JNIEXPORT jint JNICALL
Java_com_cmbc_av_jni_ImageFormatUtils_i420ToNV21(JNIEnv *env, jclass clazz, jbyteArray i420_data,
                                                 jint width, jint height, jbyteArray nv21_data) {
    uint8_t* i420Data = (uint8_t*)(*env)->GetByteArrayElements(env, i420_data,JNI_FALSE);
    uint8_t* nv21Data = (uint8_t*)(*env)->GetByteArrayElements(env, nv21_data,JNI_FALSE);
    int ret = convertI420ToNV21(i420Data, width, height, nv21Data);

    (*env)->ReleaseByteArrayElements(env, i420_data, (jbyte*)i420Data, JNI_OK);
    (*env)->ReleaseByteArrayElements(env, nv21_data, (jbyte*)nv21Data, JNI_OK);
    return ret;
}

/**
 * 6. 旋转I420数据,直接调用libyuv
 * @param env
 * @param clazz
 * @param src_data    原始I420
 * @param width       原始宽度
 * @param height      原始高度
 * @param dst_data    目标I420
 * @param rotate_mode 旋转角度
 * @return
 */
JNIEXPORT jint JNICALL
Java_com_cmbc_av_jni_ImageFormatUtils_rotateI420(JNIEnv *env, jclass clazz, jbyteArray src_data,
                                                 jint width, jint height, jbyteArray dst_data,jint rotate_mode) {
    uint8_t* srcData = (uint8_t*)(*env)->GetByteArrayElements(env, src_data,JNI_FALSE);
    uint8_t* dstData = (uint8_t*)(*env)->GetByteArrayElements(env, dst_data,JNI_FALSE);
    int ret = rotateI420(srcData, width, height, dstData,rotate_mode);

    (*env)->ReleaseByteArrayElements(env, src_data, (jbyte*)srcData, JNI_OK);
    (*env)->ReleaseByteArrayElements(env, dst_data, (jbyte*)dstData, JNI_OK);
    return ret;
}

/**
 * 7. 实现镜像功能
 * @param env
 * @param clazz
 * @param src_data      原始I420数据
 * @param width         原始宽度
 * @param height        原始高度
 * @param dst_data      目标I420数据
 * @return
 */
JNIEXPORT jint JNICALL
Java_com_cmbc_av_jni_ImageFormatUtils_i420Mirror(JNIEnv *env, jclass clazz, jbyteArray src_data,
                                                 jint width, jint height, jbyteArray dst_data) {
    uint8_t* srcData = (uint8_t*)(*env)->GetByteArrayElements(env, src_data,JNI_FALSE);
    uint8_t* dstData = (uint8_t*)(*env)->GetByteArrayElements(env, dst_data,JNI_FALSE);
    int ret = mirrorI420(srcData, width, height, dstData);

    (*env)->ReleaseByteArrayElements(env, src_data, (jbyte*)srcData, JNI_OK);
    (*env)->ReleaseByteArrayElements(env, dst_data, (jbyte*)dstData, JNI_OK);
    return ret;
}

#ifdef __cplusplus
}
#endif
#endif